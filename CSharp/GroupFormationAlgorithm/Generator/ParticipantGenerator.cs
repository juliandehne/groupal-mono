using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using GroupAL.Criteria;

namespace GroupAL.Generator
{

    class ParticipantGenerator
    {
        //list of entries
        public List<Participant> loParticipants;
        //List<Statics.AvailibleCriteria> loCriteria;
        IRule ruel;
        IParticipantReaderWriter writer;
        private IValueGenerator valueGenerator;

        /// <summary>
        /// generates a file with some entries
        /// </summary>
        /// <param name="numberOfEntriesToGenerate">how many entries should be created</param>
        /// <param name="ruel">which ruel should restrict the randomnes e.g. default ruel not lower than 0 and not higher than 1</param>
        /// <param name="methodHowToWriteEntriesOut">Which writer is going to write the entries out, e.g. XMLWriter  </param>
        public ParticipantGenerator(int numberOfEntriesToGenerate, IRule aRuel, IParticipantReaderWriter methodHowToWriteEntriesOut, string filename)
        :this(numberOfEntriesToGenerate, 2, 4, 2, 4, new UniformValueGenerator(), aRuel, methodHowToWriteEntriesOut, filename)
        {}

        public ParticipantGenerator(int numberOfEntriesToGenerate, int numhet, int dimhet, int numhom, int dimhom, IValueGenerator valueGenerator, IRule aRuel, IParticipantReaderWriter methodHowToWriteEntriesOut,string filename) {
            
            ruel = aRuel;
            writer = methodHowToWriteEntriesOut;
            this.valueGenerator = valueGenerator;
            //create list of entries with random values between 0 and 1
            loParticipants = DummyEntries(valueGenerator, numberOfEntriesToGenerate,numhet,dimhet,numhom,dimhom);

            //adjust entries by using ruel e.g. DefaultRuel map value form 0-1 to minValue-maxvalue array 
            foreach (Participant e in loParticipants) {
                ruel.AdjustParticipant(e);
            }
            

            //write them to an XML/textfile
            writer.WriteParticipantsToFile(loParticipants,filename);
        }       

        /// <summary>
        /// returns 4 perfect complementary entries
        /// </summary>
        /// <returns></returns>
        public static List<Participant> PerfectDummyEntries()
        {
            List<Participant> loEntries = new List<Participant>();
            //Perfect entries
            for (int i = 0; i < 4; i++)
            {

                Criterion c1 = new Criteria.SpecificCriterion("Bartle", 4,0,1, false, 1);
                c1.Value = new float[] { 0, 0, 0, 0};
                c1.Value[i] = 1;


                //Criterion c2 = new Criteria.SpecificCriterion("Activity", 1,0,1, true, 1);
                //c2.Value[0] = 1;

                //Criterion c3 = new Criteria.SpecificCriterion("SilvermanFelder", 4,0,1, false, 1);
                //c3.Value = new float[] { 0, 0, 0, 0 };
                //c3.Value[i] = 1;

                //Criterion c4 = new Criteria.SpecificCriterion("Age", 1,0,1, true, 1);
                //c4.Value[0] = 1;

                //Criterion c5 = new Criteria.SpecificCriterion("Spellingrate", 1,0,1, true, 1);
                //c5.Value[0] = 1;

                Participant e1 = new Participant(new List<Criterion>() { c1 });
                Participant e2 = new Participant(new List<Criterion>() { c1 });
                Participant e3 = new Participant(new List<Criterion>() { c1 });
                Participant e4 = new Participant(new List<Criterion>() { c1 });
                loEntries.Add(e1);
                loEntries.Add(e2);
                loEntries.Add(e3);
                loEntries.Add(e4);
            }
            return loEntries;
        }

        //Todo Criteria so machen dass man die gewichtung nur einmal für alle ändern muss
        /// <summary>
        /// returns p count of  Entries with 4 Criteria. The values of the Criteria are uniformly distributed(random).
        /// </summary>
        /// <param name="p">how many entries to generate</param>
        /// <returns>entries generated by random</returns>
        public static List<Participant> DummyEntries(IValueGenerator valueGenerator, int p, int numHet, int dimHet, int numHom, int dimHom, IRule _rule = null)
        {
            List<Participant> loEntries = new List<Participant>();
            List<float>[] values = new List<float>[(numHet * dimHet) + (numHom * dimHom)]; // store values here
            for (int i = 0; i < (numHet * dimHet) + (numHom * dimHom); i++)
            {
                // generate values for one specific dimension of a criterion for p players
                values[i] = valueGenerator.GenerateValues(0, 1, p);
            }

            for (int i = 0; i < p; i++)
            {
                System.Console.Out.WriteLine("Generating participant " + i + "..");
                List<Criterion> loCriteria = new List<Criterion>();
                //pseudoCriteria                
                for (int j = 1; j <= numHet; j++)
                {
                    SpecificCriterion c = new Criteria.SpecificCriterion("Khet" + j, dimHet, 0, 1, false, 1);
                    loCriteria.Add(c);
                    for (int k = 1; k <= dimHet; k++)
                    {
                        c.Value[k-1] = values[(j * k)-1][i];                       
                    }
                }
                for (int j = 1; j <= numHom; j++)
                {
                    SpecificCriterion c = new Criteria.SpecificCriterion("Khom" + j, dimHom, 0, 1, true, 1);
                    loCriteria.Add(c);
                    for (int k = 1; k <= dimHom; k++)
                    {
                        c.Value[k-1] = values[((numHet*dimHet)+ j * k)-1][i];
                    }
                }                
                Participant participant = new Participant(loCriteria);
                loEntries.Add(participant);
            }

            if (_rule != null)
            {
                foreach (Participant part in loEntries)
                    _rule.AdjustParticipant(part);
            }
            return loEntries;
        }


        public static List<Participant> DummyEntries(int p=100, IRule _rule=null)            
        {
            List<Participant> loEntries = new List<Participant>();
            for (int i = 0; i < p; i++)
            {
                List<Criterion> loCriteria = new List<Criterion>();
                
                //pseudoCriteria
                loCriteria.Add(new Criteria.SpecificCriterion("Khet1", 4, 0, 1, false, 1));
                loCriteria.Add(new Criteria.SpecificCriterion("Khet2", 4, 0, 1, false, 1));

                loCriteria.Add(new Criteria.SpecificCriterion("Khom1", 4, 0, 1, true, 1));
                loCriteria.Add(new Criteria.SpecificCriterion("Khom2", 4, 0, 1, true, 1));
                //loCriteria.Add(new Criteria.SpecificCriterion("Bartle", 4, 0, 1, false, 1));
                //loCriteria.Add(new Criteria.SpecificCriterion("BigFive", 5, 0, 1, false, 1));
                //loCriteria.Add(new Criteria.SpecificCriterion("FeldermanSilver", 4, 0, 1, false, 1));
                //loCriteria.Add(new Criteria.SpecificCriterion("MathKnowledgeIn6Topics", 6, 0, 1, false, 1));

                //loCriteria.Add(new Criteria.SpecificCriterion("Activity", 1, 0, 1, true, 1));
                //loCriteria.Add(new Criteria.SpecificCriterion("Age", 1, 0, 1, true, 1));
                //loCriteria.Add(new Criteria.SpecificCriterion("Position", 2, 0, 1, true, 1));
                //loCriteria.Add(new Criteria.SpecificCriterion("spellingfailureRate", 1, 0, 1, true, 1));

                
                Participant participant = new Participant(loCriteria);
                loEntries.Add(participant);
            }

            if (_rule != null) {
                foreach (Participant part in loEntries)
                    _rule.AdjustParticipant(part);
                }
            return loEntries;
        }

    }
}
